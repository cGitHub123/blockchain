### 基础

Peers主要是管理账本和智能合约，会暴露一些API给应用接口，Peers上面驻扎着ledger
和chaincode.

Peers是整个fabric最重要的部分，当它刚创立时，并没有ledger和chaincode.

一般一个Peers是有一个ledger，但是也可以有多个，每个leger有0个或者多个chaincode,一般至少有一个chiancode.

### 应用和peers的对话

一般客户端应用都是有个SDK，这样简化了应用和peers的对话

### 查询和更新

首先，查询和更新是不一样的，查询比较容易，只需要单个账本返回即可，更新要在查询的基础上，达成共识后再进行更新.

peers和orders共同努力，让所有的账本保持同步.

#### 查询

* 客户端应用连接到peer
* peer去执行智能合约的代码
* 智能合约去查对应的ledger
* 返回给客户端应用

#### 更新

* 完成上面查询的操作，返回给客户端应用是否可以提交更新
* 然后客户端不给peer发请求了，而是给order发更新请求
* order将请求发给对应的所有peers,对应peers返回是否可以更新
* 在上一步没完成之前order已经可以返回给客户端
* 第三步完成之后，就可以进行更新了

### peers和channel的关系

无论是客户端应用，peers，orders都加入到一个channel代表一组

### Peers和Organizations

区块链网络是由多个组织构成，每个组织包含有1个或多个peers和orders

### Peers和身份认证

每个Peer都有一个数字证书一样的身份证(像orders,应用之类的都需要)，当它连到对应的channel时，它的数字证书会指明它属于哪一个组织.

另外，channel也能根据它的身份证来知晓它对应的权限.

### Peers和Orderers

不同的节点保持一致性，需要的是order节点的参与，因为不是像查询，单个节点即可
完成.

#### 第一阶段:提议

这个阶段，我们可以自己定义多少个组织打成共识后就完成提议.每个peer都有一个身份证，返回的时候带着身份证就知道已经同意这个提议了.

当足够的peer返回后，第一阶段就完成了，至于返回的结果可能不一致.

#### 第二阶段:打包

order把客户端收到回复后发过来的已经打成共识的协议，排序，打包成一个个block(注意是已经达成共识的协议).

#### 第三阶段:校验和提交

当peer通过order或者peers之间的洪泛收到block之后，再做一边不同的校验来防止客户端发来没达成共识的请求.

校验结束后，就会提到ledger上，不一定能执行，因为assets可能已经发生了变动，但是可以确保所有ledger都一致.

在阶段三种，不需要chaincode执行，说明chaincodes是为了达成共识而生.
